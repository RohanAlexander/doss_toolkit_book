```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# DiagrammeR

*Written by Uzair Mirza and last updated on May 4 2022.*

## Introduction
This chapter focuses on making **GRAPHS**. Instead of traditional graphs, this chapter will discuss network-graphs/graphs from Graph Theory (as shown below) \
These type of graphs have multiple applications, such as- designing computer network architecture, database design, neural network design (Machine Learning), finding the the most efficient path from destination A to B (Google Maps) or even to show the workflow of a project. In general, whenever we want to represent the structure and/or flow of resources between different components of the environment, we can represent it using **GRAPHS** and in this chapter we will be exploring ways of constructing such graphs. \
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(DiagrammeR)
library(tidyverse)
```
```{r, echo=FALSE, }
a_graph <-
  create_graph(directed = FALSE) %>%
  add_node() %>%
  add_node() %>%
  add_edge(from = 1, to = 2)

render_graph(a_graph)
```
## What is **DiagrammeR**?
`DiagrammeR` is a package which allows us to make the above-mentioned graphs. Additionally, it allows us to look at the properties and perform certain operations on these graphs, which will be covered throughout this chapter. \

## Required setup
If this is your first time going over this topic, then the first thing you need to do is to install the `DiagrammeR` package which we will be using. The installation of the package is done using the following command-
```{r, eval=FALSE}
install.packages('DiagrammeR')
```
If you are familiar with this topic and need to continue your learning journey from where you left, then below is the library call you'd use before resuming. \
```{r, warning=FALSE, eval=FALSE, message=FALSE}
library(DiagrammeR)
```
## Basic Fundamentals of a Graph
The basic 2 components making a graph are: \
  - **Nodes** \
  - **Edges** \
  
### What is a Node?
A Node, also known as a Vertex in graph theory literature can be thought of as a block/briefcase containing information and having specific attributes. In a network setting, it can also be thought of as a connection point where multiple connections are formed. \
Below is an example 2 nodes `a` and `b`.\
```{r, echo=FALSE}
b_graph <-
  create_graph(directed = FALSE) %>%
  add_node(label = "a") %>%
  add_node(label = "b")
render_graph(b_graph)
```
### What is an Edge?
An Edge is the connection/link between nodes. The best way to think about edges is with an example of a map where each city represents a Node, where the Edge is the highway connecting those 2 cities. \
Below is the continuation of the previous example, where now we have 2 **edges connecting**- one from `node a` to `node b` and the other from `node b` to `node b`. \
```{r, echo=FALSE}
b_graph <- b_graph %>% add_edge(from = "a",
                                to = "b") %>%
                         add_edge(from = "b",
                               to = "b") 
render_graph(b_graph)
```
**NOTE** you cannot have a standalone edge without any nodes being present. This is because as we've established that edge is a **connection** either between 2 nodes or the node itself. Think of this as, a purposeful bridge(edge) needs land(node) in order for it to exist.

## Graphs
We can think of Graphs as an empty blank sheet on which a map(nodes + edges) are laid upon. Here from the previous statement made about the edges we can also see a valid graph can exist with just the nodes without any edges. Intuitively think about the map example again, for a road (EDGE) to exist you always need a start point and an end point. However, an isolated city (NODE) can exist without any connections with other cities.  \
So here a node alone can make for a valid graph. \

Just one more thing to add that a graph can have properties an example of such property is being a **directed graph\digraph**. A graph is said to be **directed** if the edges between the nodes have a direction/flow of information around them. Example of the above graph being directed can be seen below.8
```{r, echo=FALSE, warning=FALSE}
rm(list=ls())
b_graph <-
  create_graph(directed = T) %>%
  add_node(label = "a") %>%
  add_node(label = "b")

b_graph <- b_graph %>% add_edge(from = "a",
                                to = "b") %>%
                         add_edge(from = "b",
                               to = "b") 
render_graph(b_graph)
rm(list=ls())
```
In the above example based on the properties of edges we can see that we can only travel from node `a` to `b` but not from `b` to node `a`. \
To summarize what we have covered so far: \
- Node: A component of a graph which can be visualized as a capsule containing information and often representing a connection point for edges. \
- Edge: This is the connection running from one node to another. \
- Graph is an object which shows and displays the relation between nodes and edges. \

### Syntax
#### Graph
The first step when making a graph is to actually declare the graph object. This is how you declare a graph using `create_graph()` function . \
```{r, create_graph}
graph <- create_graph()
```
As the name suggests `create_graph()` function is used to create the graph object. Getting back to the map example think of this `create_graph()` function as laying down the blank sheet of paper(Graph) where you will be adding your cities(Nodes) and roads(edges).\

Note there are more arguments which may be passed when creating graphs, below is the basic syntax along with the breakdown of of the arguments.
```{r, eval=FALSE}
create_graph(nodes_df = NULL, edges_df = NULL, directed = TRUE,
  graph_name = NULL, attr_theme = "default", write_backups = FALSE)
```
```{r, echo=FALSE}
Arguments <- c("`nodes_df`", "`edges_df`", "`directed`",
  "`graph_name`", "`attr_theme`", "`write_backups`")

node <- "A VALID node data frame."
edge <- "A VALID edge data frame."
directed <- "A boolean to declare if the graph is **directed** or not. By default set to `TRUE`"
name <- "An optional string attribute to label the graph"
attr <- "A global theme which is set for the graph(both edges and nodes). If not selected then `default` attributes are applied globally and if declared as `NULL` then NO attributes are applied"
write <- "When set as `TRUE` each change in state is stored in a subdirectory in the current working directory, by default it is set to `FALSE`"

Description <- c(node, edge, directed, name, attr, write)

graph_list <- data.frame(Arguments, Description)
knitr::kable(graph_list)
```
To graphically view a graph we use the command `render_graph()` to view the graph object.
```{r, eval=FALSE}
# renders the empty graph we previously declared
render_graph(graph)
```
Now is a good time to introduce the syntax for **DIRECTED** graphs, which are obtained when we set the argument `directed = TRUE` in our graph. \
Well as the name suggests and to recap, directed graphs are graphs where the flow/movement between the nodes along the edge is specific to a particular direction. Below is an example of a directed graph, we use `from = ` to declare the start of the edge and `to =` to declaring the ending point.
```{r, echo=FALSE}
graph.dir <- create_graph()

graph.dir <- graph.dir %>% 
  add_n_nodes(n=3) %>%
  add_edge(from = 1, to = 2) %>%
  add_edge(from = 1, to = 3) %>%
  add_edge( from = 2, to = 3) %>%
  add_edge(from = 3, to = 1)

render_graph(graph.dir)
```
The breakdown of the above example is as follows; If we think about these integers `label` as sectors from Hunger Games, then what these edges show is the possible movement from one sector to another. With this given example we can denote that we can move between sector 1 and sector 3 BUT can only enter sector 2 from sector 1 and can only exit to sector 3 once we're in sector 2. \
Another way is to think about the direction and movement as the road system, some roads allow you to travel in only 1 direction while others allow you to travel in both the directions. \

***The discussion about node data frames and edge data frames will be covered in the coming sections.*** \

#### Node
Now that we are familiar with how graphs work and the basic syntax for a graph, let us look at nodes and some properties related to nodes.
The `add_node()` function is used to add a node to an already present graph. \
In the code below we're adding a single node to the previously declared empty graph object `graph`.
```{r, add_node}
graph <- graph %>% 
  add_node()
```
Here we first refer to the variable storing our graph as `graph_a`, then we use the PIPE `%>%` operator which tells R to perform the operation on our specified variable. Then, the `add_node()` function adds a default node to our specified graph. \
Let us now populate our graph `graph_a` with `c` more nodes using `add_n_nodes(n=c)` and **DISPLAY** our graph using the `render_graph()` function. \
```{r, node_and_render}
# Adding 3 more new nodes to the graph
graph <- graph %>%
  add_n_nodes(n = 3)

# Display our graph
render_graph(graph)
```
How about we delete a node now? The `delete_node(node=ID)` command is used to delete a node from a graph. Here `ID` is the **unique identity** which identifies each node in a graph. \
To get a list of all the identities in a graph, we use the `get_node_ids()` command. Here is an example of using both of these commands. \
```{r, node_ID}
graph %>% get_node_ids()
```
Deleting `node 4` in our graph. \
```{r, delete_node}
graph <- graph %>%
  delete_node(node = 4)
```
Let us check if the node was deleted in both the ways by checking the `ID` and also visually. \
```{r}
get_node_ids(graph)
```
Here, take note of a new way we used to call the function. So now you have 2 ways of calling the function however the method we learned earlier is preferred as it is easier to read. \
Just to confirm, let us print out the graph and see if the node is actually removed. \
```{r}
render_graph(graph)
```
Let us now look at some more arguments we can pass when declaring a node. We will first look at the general declaration syntax, followed by the description of the arguments. \

```{r,add_node_all, eval=FALSE}
add_node(type = NULL, label = NULL, from = NULL, to = NULL,
  node_aes = NULL, edge_aes = NULL, node_data = NULL,
  edge_data = NULL)
```
**`type`** \ 
This is character type holder, which is used to group nodes together. This can be thought of as a parameter to pass into `group_by()` for further analysis. Think of the map example again with all the cities. Here you might choose to group the cities based on the province they belong to by declaring the type. \
**`label`** \
This can be thought of as the wrapper which is displayed on top of the node when the graph is displayed. So in our map example the city names will be used as the `label`. \
**`node_aes`** \
In addition to grouping similar nodes together, we can also change node attributes such as `shape`, `color`, `size`, depending on the need. It is recommended to use the helper function of `node_aes()` when assigning the aesthetics. \
Below is a table which lists some of the mutable aesthetic options available to choose from. The complete list of options can be found [here](http://visualizers.co/diagrammer/reference/node_aes.html#examples).
```{r, eval=FALSE}
node_aes(shape = NULL, style = NULL, color = NULL,
  fillcolor = NULL, fontname = NULL, fontsize = NULL,
  fontcolor = NULL, height = NULL,
  width = NULL, x = NULL, y = NULL, group = NULL,
  xlabel = NULL, URL = NULL, sides = NULL, margin = NULL)
```

```{r, node_aes_table, echo=FALSE}
# Making a table detailing some aesthetic options
Arguments <- c("`shape`", "`style`", "`color`",
  "`fillcolor`", "`fontname`", "`fontsize`",
  "`fontcolor`", "`height`", "`width`", "`x`", "`y`", "`group`", "`xlabel`",
  "`URL`", "`sides`", "`margin`")

shape <- "Shapes a node can take, eg: `circle`, `rectangle`, `polygon`, `plaintext`"
style <- "Possible style/pattern of the node, eg: `filled`, `invisible`, `diagonals`"
color <- "The color of the outline of the node. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
fillcolor <- "The color to fill the node with. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
fontname <- "The font system which will be used for the label"
fontsize <- "The size of the label"
fontcolor <- "The color of the label. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
height <- "The height of a node, the minimum possible is `0.02`. Note: if the label is unable to fit in the specified height, the height will be adjusted to fit the label"
width <- "The width of a node, the minimum possible is `0.02`. Note: if the label is unable to fit in the specified width, the width will be adjusted to fit the label"
x <- "Fixes the positioning of the node in the specified x-coordinate direction"
y <- "Fixes the positioning of the node in the specified y-coordinate direction"
group <- "This is the group to which the node belongs"
xlabel <- "A label that is placed outside but close to the node, PROVIDED the label doesn't overlap with other nodes"
URL <- "Assigns the URL associated with the node and upon clicking, the node will redirect to the specified URL"
sides <- "When the `shape` is `polygon`, this specifies the number of sides for the polygon"
margin <- "The amount of space between the label and the node"

Description <- c(shape, style, color, fillcolor, fontname, fontsize,
  fontcolor, height, width, x, y, group, xlabel,
  URL, sides, margin  )

aes <- data.frame(Arguments, Description)
  
knitr::kable(aes)
```
**`node_data`** \
This is a list of named vectors you can initialize to add some data into your node. In the map example, you can add data about the population density, area and other attributes about a node using this. Similar to aesthetics, the recommended helper function to add data is `node_data()`. \
**`from`** \
This is vector or single `ID` value which can be used to form an **incoming** edge with nodes that are already present in the graph.\
**`to`** \
This is vector or single `ID` value which can be used to form an **outgoing** edge with nodes that are already present in the graph.\
**`edge_aes`** \
Similar to `node_aes`, this field deals with aesthetic attributes of the edges connecting this note. We will cover this in the section dealing with Edges, the syntax along with the declaration will remain the same. \
**`edge_data`** \
Similar to `node_data`, this field deals with the data that can be stored in an edge. This will be covered in the section dealing with Edges, the syntax along with the declaration will remain the same. \
```{r, echo=FALSE}
rm(list=ls())
graph <- create_graph()
```
Now let's connect these new things to our original example of the map. Here, we will be first declaring the `type` as "city", along with the name of city which will be stored as a `label`. We will be adding some aesthetics to our node along with some `node_data` and the link to the Wikipedia page for [Toronto](https://en.wikipedia.org/wiki/Toronto). \
```{r}
graph <- graph %>% add_node(type = "city", label = "Toronto",
                node_aes = node_aes(shape = "rectangle", style = "filled",
                                    color = "Red", fillcolor = "Black",
                                    fontcolor = "Blue",
                                    fontsize = 9,
                                    URL = "https://en.wikipedia.org/wiki/Toronto"),
                node_data = node_data(area = 630.2, population = 2.7,
                                       GDP = 385.1, provience = "Ontario"))

render_graph(graph)
```
Now note in the render of our graph we can see the `label` and aesthetic features of our node **BUT** we have no idea about what data is stored in the node. \
To get the information stored in our node we use the `get_node_df()` function. 
```{r, node_df}
graph %>% get_node_df()
```
What is being displayed above is a data frame, which is formally known as **Node Data Frame(NDF)**. \

##### Node Data Frame(NDF)
The main concept and reasoning behind having an NDF is firstly, as previously discussed one cannot get an idea about the data stored in a node with the visual representation. Secondly, it is not efficient (in terms of computation) to always re-run the code and reconstruct your graph when choosing to pause your work and resume it at a later date.
Here, it would to be much more easy to reconstruct and store these nodes instead, and this is where NDF comes into play. \
Previously we looked at how to extract the NDF using `get_node_df()` command. Now to create an NDF, we use the function `create_node_df()`. Here is the basic syntax for it along with the breakdown of the arguments it takes.
```{r, eval=FALSE}
create_node_df(n, type = NULL, label = NULL, ...)
```
```{r, echo=FALSE}
Arguments <- c("`n`", "`type`", "`label`", "`...`")
n <- "The total number of nodes in the dataframe"
type <- "The optional `type` for EACH node"
label <- "Optional `label` for EACH node. `label = TRUE` assigns the `ID` as `label`"
data <- "Aesthetic attributes and Node data can be declared here"

Description <- c(n, type, label, data)
node_data <- data.frame(Arguments, Description)
knitr::kable(node_data)
```
Here is an example of creating an NDF similar to the theme of previous examples. For the purpose of simplicity, we will not be adding a lot of data variables in our nodes.
```{r}
node_df <- create_node_df(n = 3, type = "city", 
                          label = c("Toronto", "Ottawa", "Montreal"),
                          shape = "rectangle", style = "filled",
                          color = "Red", fillcolor = "Black",
                          fontcolor = "White",
                          provience = c("Ontario", "Ontario", "Quebec"))
```
```{r, echo=FALSE}
# displaying the results
node_df
```
Looking at the results of the previous command, we can see that we have a data frame with 3 nodes along with their attributes. Note this is similar to the regular data frames in R and can be created using `data.frame()`. However, `create_node_df()` is recommended as it allows for further validation (eg: checks `id` for the nodes).  [2](https://rich-iannone.github.io/DiagrammeR/ndfs_edfs.html) \


Let us conclude this section with looking at how to merge two or more NDFs into one. To do this, we use the `combine_ndfs()` function call. Here is an example- \
```{r}
# making 2 NDFs
node_df1 <- create_node_df(n = 2, 
                           type = c("a", "b"),
                           shape = "rectangle",
                           data = c(1,2)
                           )
node_df2 <- create_node_df(n = 2, 
                           type = c("c", "d"),
                           label = c("C", "D"),
                           data = c(3,4)
                           )
# merging the 2 NDF into 1
main_NDF <- combine_ndfs(node_df1, node_df2)
```
```{r, echo=FALSE}
main_NDF
```
Note that from the results we can notice that attributes which are not common among the data frames are not excluded in the merged data frame, but are assigned `NA` and similarly new `ID` values are assigned to the nodes to prevent any overlap of `ID`. \

This concludes our discussion about the Nodes, the last detail about constructing graphs from an NDF will be covered in a later section. \


#### Edge
Recall that an edge is defined as a connection/link between nodes. Depending on the graph being directed or not, the direction of travel on an edge between nodes can be specific. Furthermore, **NOTE** that for an edge to exist we need a minimum of 1 node. For the purpose of simplicity, we will be working with directed graphs for most of this section.\

Let us look at the basic syntax used for creating an edge and, the required and possible arguments along with their description.
```{r, eval=FALSE}
add_edge(graph, from, to, rel = NULL, edge_aes = NULL,
  edge_data = NULL)
```
**`graph`** \
This is the  `graph` object to which the edge will be added. Can also use `%>%` feature to avoid the declaration shown above eg: \
```{r, eval=FALSE}
#Can use this declaration
my_graph %>% add_edge()

# Or this
add_edge(my_graph)
```
**`from`**\
The starting-node/outgoing-node/exiting-node, from which the edge is connected. Here we can use the `label` of the node IF all the labels are non-empty and are unique strings. By default `id` should be used as they are unique and hence less prone to errors + `id` are never empty as THEY ARE NOT an optional argument. \
**`to`** \
The ending-node/incoming-node/entering-node, from which the edge is connected. Here we can use the `label` of the node IF all the labels are non-empty and unique strings. As is the case of `from`, by default `id` should be used and likewise THIS IS NOT an optional argument. \
**`rel`** \
Can use this `string` type attribute to declare a relation between the 2 nodes being connected with the particular edge. \ 
**`edge_aes`** \
Similar to `node_aes` from the previous section, we use this optional attribute to add and declare a list of aesthetic attributes to our edge. It is recommended to use the `edge_aes()` helper function to declare aesthetics. \
Below is the basic syntax to declare some of the common aesthetics along with their description followed by a simple example. The complete list of attributes can be found [here](http://visualizers.co/diagrammer/reference/edge_aes.html).
```{r, eval=FALSE}
edge_aes(style = NULL, penwidth = NULL, color = NULL,
  arrowsize = NULL, arrowhead = NULL, fontname = NULL, 
  fontsize = NULL, fontcolor = NULL, len = NULL,
  tooltip = NULL, URL = NULL, label = NULL, labelURL = NULL, 
  dir = NULL, headURL = NULL, headlabel = NULL, tailURL = NULL, 
  taillabel = NULL)
```
```{r, echo=FALSE}
Arguments <- c("`style`", "`penwidth`", "`color`",
  "`arrowsize`", "`arrowhead`",
  "`fontname`", "`fontsize`", "`fontcolor`", "`len`",
  "`tooltip`", "`URL`", "`label`", "`labelURL`", 
  "`dir`", "`headURL`", 
  "`headlabel`", "`tailURL`", "`taillabel`")

style <- "The style, visual render of the edge, eg: `solid`, `bold`, `dotted`"
penwidth <- "The thickness of the arrow"
color <- "The color of the outline of the edge. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
arrowsize <- "The scaling factor associated with the arrow, the minimum is `0.0` and the default value is `1.0`."
arrowhead <- " The style associated with the arrow head, can choose any from: `normal`, `vee`, `tee`, `dot`, `diamond`, `box`, `curve`, `icurve`, `inv`, `crow`, or `none`."
fontname <- "System of font to be used for ANY edge text"
fontsize <- "The font size to be used for ANY edge text"
fontcolor <- "The color of ANY edge text. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
len <- "The length for the edge, the default is set to `1.0`"
tooltip <- "The text to display when hovering over an edge. If no argument is provided, then the edge defination is displayed (ie: [id_i] -> [id_j])."
URL <- "When a URL is provided, clicking on the edge will redirect to the provided URL."
label <- "The text displayed on the edge, it is positioned at the center of the edge"
labelURL <- "When a URL is provided, clicking on the 'label' will redirect to the provided URL."
dir <- "An optional direction type. This will be set to 'none' by default for undirected graphs and to 'forward' for directed graphs. One can declare and assign `both` or `back` to overwrite the default value and have the direction reversed OR make a multidirectional edge"
headURL <- "When a URL is provided, clicking on the 'label' of the head will redirect to the provided URL."
headlabel <- "The text displayed close to the incoming node"
tailURL <- "When a URL is provided, clicking on the 'label' of the tail will redirect to the provided URL."
taillabel <- "The text displayed close to the outgoing node"

Description <- c(style, penwidth, color,
  arrowsize, arrowhead,
  fontname, fontsize, fontcolor, len,
  tooltip, URL, label, labelURL, 
  dir, headURL, 
  headlabel, tailURL, taillabel)

edge_aes_data <- data.frame(Arguments, Description)
knitr::kable(edge_aes_data)
```
**`edge_data`**\
This is used to store data associated with an edge. Think about the previous map example- we can associate the average gas cost for taking a particular route by assigning gas prices along the edge or the time it will take to travel between the areas (nodes) using that edge. The helper function `edge_data()` is recommended to use when declaring edge data. Following is the syntax to use the function. \
```{r, eval=FALSE}
edge_data()
```

Let us cement these concepts about edges with an example. The graph we will be working with is representative of the two popular tourist destinations shown below and we will be building upon this example.
```{r,}
graph <- create_graph()
graph <- graph %>% add_n_nodes( n = 2,
                      label = c("Toronto", "London"), node_aes(fontsize = 7))
render_graph(graph)
```
As we can see currently, this graph has 2 labeled nodes. Let us add some edges between these nodes to show the possible flights between the 2 locations along with the associated fares and other details.   \

```{r}
graph <- graph %>% add_edge(from = "Toronto", to = "London",
                   edge_aes = edge_aes(style = "solid",
                                       color = "Red",
                                       label = "Air Canada",
                                       labelfontsize = 3,
                      URL = "https://www.aircanada.com/us/en/aco/home.html"),
                   edge_data = edge_data(cost = 1000, 
                                         layover = "Yes", time = 17)) %>%
            add_edge(from = "Toronto", to = "London",
                             edge_aes = edge_aes(style = "solid",
                                                 color = "Blue",
                                                 label = "British Airways",
                                                 labelfontsize = 3,
                      URL = "https://www.britishairways.com/travel/home/public/en_ca/"),
                             edge_data = edge_data(cost = 2000, layover = "No",
                                                   time = 13)) %>%
    add_edge(from = 2, to = 1,
                   edge_aes = edge_aes(style = "solid",
                                       color = "Blue",
                                       labelfontsize = 3,
                      URL = "https://www.britishairways.com/travel/home/public/en_ca/"),
                   edge_data = edge_data(cost = 1300, layover = "Yes", time = 19)) %>%
  add_edge(from = 2, to = 1,
                   edge_aes = edge_aes(style = "solid",
                                       color = "Red",
                                       labelfontsize = 3,
                      URL = "https://www.aircanada.com/us/en/aco/home.html"),
                   edge_data = edge_data(cost = 1000, 
                                         layover = "Yes", time = 17))
render_graph(graph)
```
In the above example we added 4 edges along with some aesthetics to these edges depending on the condition we also added `URL` directing to the airlines websites and lastly we added some data to the edges. Here as we can see the data is not visible from the visual render of the graph. \
To get this data we use the function `get_edge_df()`, here is the use case for our example. \
```{r}
graph %>% get_edge_df()
```
So what is being displayed here is a data frame known as **Edge Data Frame(EDF)**. \
Think that now all the flights from Toronto to London are not operational for the time being. To account for this change we use `delete_edge()` function.
```{r}
graph.update <- graph %>% delete_edge(from = 2, to = 1)
```
```{r, echo=F, eval=FALSE}
## Not able to delete specefic edges
#graph.update <- graph %>% delete_edge(id = 1)
```
```{r, echo=FALSE}
render_graph(graph.update)
```
#### Edge Data Frame(EDF) 
The main concept and reasoning for having EDF is firstly as previously discussed one cannot get an idea about the data stored in an edge with the visual representation and because of the associated complexity involved re-running the code hence it is beneficial to view the dataframe instead for quick changes. \
Now to reconstruct and store these edges EDF we use the help of the following functions.\

We have looked at how to extract the EDF using `get_edge_df()` command. Now to create an EDF we use function `create_edge_df()`. Here is the basic syntax for it along with the breakdown of the arguments it takes. \
```{r, eval=FALSE}
create_edge_df(from, to, rel = NULL, ...)
```
```{r, echo=FALSE}
Arguments <- c("`from`", "`to`", "`rel`", "`...`")
from <- "A vector of `integer` containing node `id` from which the edges are leaving. This vector length must match the `to` vector's length"
to <- "A vector of `integer` containing node `id` where the edges are entering. This vector length must match the `from` vector's length"
rel <- "A`chracter` argument that can be passed to show the relation between the nodes "
dat <- "This is where all the attributes related to the aesthetics and data can be declared and stored."
Description <- c(from, to, rel, dat)

edf_data <- data.frame(Arguments, Description)
knitr::kable(edf_data)
```
Now often times we will be required to combine multiple EDFs in one main EDF. We do this using the `combine_edfs(..., ..., ....)` function where `...` are valid EDFs. \
Below in an example which covers both creating and merging of 2 simple EDFs.
```{r}
# Creating the EDF
edf.a <-
  create_edge_df(
    from = c(1, 2, 3),
    to = c(2, 3, 1),
    value = c(10, 20, 50),
    color = "Blue")
edf.b <- create_edge_df(
    from = c(4, 4, 5),
    to = c(6, 5, 6),
    data = c(11, 20, 50),
    color = "Red")

# Merging the EDF
(main_edf <- combine_edfs(edf.a, edf.b))
```

Note from the results we can notice the attributes which are not common among the data frames are not excluded in the merged data frame but are assigned `NA` and new `id` values are assigned to the edges preventing any overlap of `id`. \

This concludes our discussion about the Edges and now we have all the necessary tools to construct graphs directly given a valid NDF and EDF. \

#### Constructing graphs from EDF and NDF
Now that we have an idea about how EDF and NDF work let us now look at how we can link these two to construct a graph. \
Recall from the section where we discussed `create_graph()` the two arguments `node_df` and `edge_df` will now be declared to make a graph. Lets go over a quick example where we declare the NDF and EDF and then combine the two into a graph object. \
```{r}
# Create a node data frame
ndf <-
  create_node_df(
    n = 3,
    label = c("1", "2", "3"),
    type = "lower",
    style = "filled",
    color = "Pink",
    shape = "diamond")

# Create an EDF
edf <-
  create_edge_df(
    from = c(1, 2, 3, 2, 4),
    to = c(3, 3, 1, 1, 5))

# Create the graph from NDF and EDF
graph <-
  create_graph(
    nodes_df = ndf,
    edges_df = edf)

render_graph(graph)
```
Voila! We finally have constructed a graph object from NDF and EDF. Here one thing to note is that for the `id` which don't match, in our case {4,5} coming from EDF our new graph object has created 2 more nodes to account for this. \
This shows that when combing EDF and NDF the number of nodes in the final graph is not limited to the dimension of the NDF BUT also includes the length of the Union of the unique `from` and `to` vector. \

### Fishy behaviour, Edge casses and Common Errors
In this section we will build up cases from simple examples and investigate what happens and the reasoning behind these cases. \

Look at the code below, before looking at the output based on the intuition from the previous lesson we should expect an error message as; Here we are first declaring a graph object followed by the addition of 2 nodes which will be assigned `id = 1` & `id = 2` as the default declaration behavior. However when declaring edges we can see the declared edge statement is not referring to any of the node `id` we previously declared in the graph. \
Instead we are referring to new node `id`s and the default behavior in this case is that new nodes for `id = 3` and `id = 4` are created. \
```{r, warning=FALSE}
graph <-
  create_graph(directed = FALSE) %>%
  add_node() %>%
  add_node() %>%
  add_edge(from = 4, to = 3)

render_graph(graph)
```
Seeing this behavior, one can make a case of declaring connected edges using the edge declaration statement alone. But care must be taken as in the case of a having large complex graphs we will run into situations that **if we enter a wrong node ID** then instead of raising an error this default behavior will result in the creation of a new node.  \
```{r, echo=FALSE}
rm(list=ls()) 
```
Next, a common error encountered is when we fail to mention the `to =` or `from =` in the edge declaration.
Let us copy of the previous example and see the situation where this error can occur.
```{r, error=TRUE}
graph <-
  create_graph(directed = FALSE) %>%
  add_node() %>%
  add_node() %>%
  add_edge(from = 4, )
```
Here the error statement is clear and explicitly states the detail about the `to =` is missing in the edge declaration function. \

Recall the work we did with Node Data Frames(NDFs). The example we covered was where we declared the 3 nodes and assigned `label` and stored some data and aesthetic for the nodes. \
Initially when creating nodes we mentioned that if the `label` is not specified then the `ID` of the node is used as the `label`. However this is not the case when creating nodes using the `create_node_df()`. Although this might seem surprising when comparing the behavior against `add_node()` or `add_n_nodes()` BUT recall we also mentioned that NDF are like simple data frames hence a field not explicitly declared(***other than `id`***) then it will not be automatically assigned a value. \
In the example below we can see that if the `label` and `type` are not declared manually then they will be assigned `NA`. \
```{r}
(create_node_df(n = 3))
```
A common source of error is when we choose to declare labels manually for some of the nodes but we don't declare them for others.
```{r, error=TRUE}
(create_node_df(n = 3, type = "city", 
                    label = c("Toronto", "Ottawa"),
                    shape = "rectangle",
                    provience = c("Ontario", "Ontario", "Quebec")))
```
Here based on the default behavior from the previous example we can expect `NA` to be assigned for the values not specifically assigned but instead we get an error. \
Hence care must be taken to match all the `labels` to the desired nodes in order for the error to not happen hence for this example we need exactly 3 labels for our example. \

Similarly lets examine the case for Edge Data Frames(EDFs). As is the case with the NDFs for each Node `ID` declared in`from =` we need to match a Node `ID` in `to =`. \
Also by default if the `rel` are not declared explicitly then `NA` values are assigned to these values.
Stemming from these two behaviors some common errors are as follows:
```{r, error=TRUE}
(create_edge_df(
    from = c(1, 2, 3, 2),
    to = c(3, 3, 1, 1, 5)
    ))
```
As the error states we need to have the number of node `ID` in `to` and `from` to match.\

## Graphviz and Mermaid
### Graphviz
Another way of declaring and making graphs is through Graphviz which requires the declaration of graph through **DOT** language. **DOT** language is a simple graph description language. DOT allows us to make highly customization graphs and add extra aesthetics to all the components of a graph. \

The basic syntax to add the graph and the breakdown of some of the common possible arguments is as follows;
```{r, eval=FALSE}
grViz("
# selecting the graph to be a directed graph
digraphs{ ... }
      ")
```
We pass in the argument in plain text `DOT` language into the `grViz()` function which renders and displays the graph according to our arguments. \
We now need to look at the breakdown of the `DOT` language. We begin with first declaring whether the graph is going to be directed graph(aka. digraph) or not, which is done by;
Directed graph as `"digraph{ ... }"` un-directed/normal graph as `"graph{ ... } "`. \
Next we fill in the above bracket, we add a graph statement, this is where we add the abstract aesthetic details which will be applied and inherited among all the attributes of the graph. \
Below we can see how we continue building our graph.
```{r, eval=FALSE}
grViz("
digraph {

  # a 'graph' statement
  graph [fontsize = 10]
  
  ... }
  ")
```
Now that we have the graph object ready, it is a good time to add some nodes to our graph. Adding nodes to the graph is similarly simple, to declare node we first declare the aesthetics of the nodes followed by the labels for each node. It is done as follows;
```{r, eval=FALSE}
grViz("
digraph {
  graph [fontsize = 10]

  # `Node` statement
    ## adding aesthetics
  node [shape = egg,
        fontname = Helvetica]
    ## Labels for each node being declared
  label_A; label_B; label_C;
  
  ... }
  ")
```
Note in the above declaration of the nodes the noes being added are declared in a group this is done so that they can have similar attributes. \
To declare another group of nodes we do it similarly as done with the initial node statement. \
The next and the final step is to add edges to our graph. We use the `label` of the nodes along with `"->"` to declare the edges of a graph as seen in the example below along with the resulting graph.
```{r}
grViz("
digraph {
  graph [fontsize = 10]
  node [shape = egg,
        fontname = Helvetica]
  Node_A; Node_B; Node_C;
  
  # 'edge' statements
  Node_A->Node_B
  Node_B->Node_C
  }
  ")
```
Below is an example of a graph which covers most of the common conditions discussed above, this example is of a processing and path information takes to process a user request.
```{r}
grViz("
# selecting the graph to be a directed graph
digraph {
  # a 'graph' statement
  graph [fontsize = 10]

  # several 'node' statements
  node [shape = egg,
        fontname = Helvetica]
  analogue_to_binary; processing; binary_to_analogue; Output; 

  node [shape = diamond,
        fixedsize = true,
        width = 0.9] 
  Input; Output; Sound; Visual

  # several 'edge' statements
  Input->analogue_to_binary 
  analogue_to_binary->processing
  processing->binary_to_analogue 
  binary_to_analogue->Output
  Output->Sound Output->Visual
}
")
```
We have covered the basic working and the syntax of graphs using the GraphViz but as discussed earlier GraphViz is highly customizable and a complete documentation along with the examples can be found [here](http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html).

### Mermaid
Similarly to DOT language in GraphViz, Mermaid library from the DiagrammeR package uses similar instructions in a string format to construct graphs. Mermaid is usually used a preferred to make sequential diagrams. \
The basic syntax used to make Mermaid and the breakdown of syntax is as follows. \ 
We use the `mermaid( "..." )` function to make the graphs.
```{r, eval=FALSE}
mermaid( "..." )
```
In the above declaration ` "..." ` are the instructions used to make the graph. \

We first define the layout for the graph as how the graph should be laid out, should it flow according to one of the following forms; \
Left to Right `LR` \
Right to Left `RL` \
Top to bottom `TB` \
Bottom to top `BT` \
Top down (similar to `TB`) `TD` \
```{r, eval=FALSE}
mermaid("graph LR
        ...
        ")
```
Next we add some Nodes to our graph. The format of declaring the node is; \
`[ID][opening brace][label][closing brace]`
As the name suggests `ID` is the unique ID for the node. \
Similarly `label` of the node is what is displayed on the node. \
The shape of the node is dependent on the choice of the `opening brace` and `closing brace`. Below is a table for the shapes with the braces used to generate them;
```{r, echo=FALSE}
Shape <- c("Rectangular", "Rounded Rectangle", "Circle", "Rhombus", "Flag")
rec.open <- "["
rec.close <- "]"

r.rec.open <- "("
r.rec.close <- ")"

cir.open <- "(("
cir.close <- "))"

rh.open <- "{"
rh.close <- "}"

fl.open <- ">"
fl.close <- "]"

Opening <- c(rec.open, r.rec.open, cir.open, rh.open, fl.open)
Closing <-c(rec.close, r.rec.close, cir.close, rh.close, fl.close)

mermaid_data <- data.frame(Shape, Opening, Closing)
knitr::kable(mermaid_data)

```
To make a directed edge we make it using `"-->"` and `"---"` for an un-directed edge.\
Now that we have all the tools let us build our basic graph using all the edge types and shapes.
```{r}
mermaid("
graph LR
A((Circular))-->B[Rectangular]
B---C>Flag Node]
C-->D(Rounded Rectangle)
C-->E{Rhombus}
")
```
A slight drawback of Mermaid is that it is limited with the amount of aesthetics available for nodes and edges. Hence GraphViz should be used to make graphs which require custom aesthetics and Mermaid should be used to make Sequential graphs.
We have covered the basics for the syntax for using the mermaid library, more can be read about sequential diagrams using the GraphViz package [here](http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html).



## Exercise
Q1. You can have a(n) ___ without a(n) ____ ?    \
a. Edge, Node \
b.  Node, Edge \

Q2. You can have a valid graph without ___ ?
(hint: what happens when you pass `create_graph()` without any arguments) \
a. an edge but not without a node \
b. a node but not an edge \
c.  an edge or a node  \

Q3. A loop in a graph is when we have an edge starting and ending on the same node? \
a.  True \
b. False \

Q4. `get_node_info()` is used to view the data in a node? \
a.  False \
b. True \

Q5. NDFs with common `id` and `label` can merge into 1 NDF? \
a.  True \
b. False \

Q6. When NDF and EDF are combined into a graph object, the number of nodes depends on NDF only? \
a. True \
b.  False \

Q7. NDF and EDF can be created using `data.frame()` command instead of their specific commands? \
a.  True \
b. False \

Q8. `add_node(n=3)` will add 3 nodes to the graph? \
a. True \
b.  False \

Q9. `add_n_edges(n=2)` with valid `to` and `from` arguments will add 2 edges to the graph? \
a. True \
b.  False \
 
Q10. When making a graph from NDF and EDF the number is edges is determined by the length of `to` or `from` vector? \
a.  True \
b. False \


## Refrences
`DiagrammeR` \
[Introduction](http://visualizers.co/diagrammer/) \
[Applications](https://www.javatpoint.com/graph-theory-applications#:~:text=Graphs%20are%20used%20to%20represent%20networks%20of%20communication.&text=Graph%20theory%20is%20used%20to,shortest%20path%20between%20two%20nodes.) \

`Node` \
[Adding node](http://visualizers.co/diagrammer/reference/add_node.html) \
[Node Aesthetic](http://visualizers.co/diagrammer/reference/node_aes.html) \
[Node Data](http://visualizers.co/diagrammer/reference/node_data.html) \
[NDF](http://visualizers.co/diagrammer/reference/add_node_df.html)\

`Edge` \
[Adding Edge](http://visualizers.co/diagrammer/reference/add_edge.html)
[Edge aesthetics](http://visualizers.co/diagrammer/reference/edge_aes.html) \
[Edge Data](http://visualizers.co/diagrammer/reference/edge_data.html) \
[EDF](http://visualizers.co/diagrammer/reference/add_edge_df.html) \

`EXTRA` \
[Function List](http://visualizers.co/diagrammer/reference/index.html) \