
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
```

# DiagrammeR

*Written by Uzair Mirza and last updated on February 5 2022.*
## Introduction
This chapter focuses on making **GRAPHS**. Instead of traditional graphs, this chapter will discuss network graphs/graphs from Graph Theory (as shown below) \
These type of graphs have multiple applications, such as- designing computer network architecture, database design, neural network design (Machine Learning), finding the the most efficient path from destination A to B (Google Maps) or even to show the workflow of a project. In general, whenever we want to represent the structure and/or flow of resources between different components of the environment, we can represent it using **GRAPHS** and in this chapter we will be exploring ways of constructing such graphs. \
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(DiagrammeR)
library(tidyverse)
```
```{r, echo=FALSE, }
a_graph <-
  create_graph(directed = FALSE) %>%
  add_node() %>%
  add_node() %>%
  add_edge(from = 1, to = 2)

render_graph(a_graph)
```
## What is **DiagrammeR**?
`DiagrammeR` is a package which allows us to make the above-mentioned graphs. Additionally, it allows us to look at the properties and perform certain operations on these graphs, which we will be covered in this chapter. \

## Required setup
If this is your first time going over this topic, then the first thing you need to do is to install the `DiagrammeR` package which we will be using. The installation of the package is done using the following command-
```{r, eval=FALSE}
install.packages('DiagrammeR')
```
If you are familiar with this topic and need to continue your learning journey from where you left, then below is the library call you'd use before resuming. \
```{r, warning=FALSE, eval=FALSE, message=FALSE}
library(DiagrammeR)
```
## Basic Fundamentals of a Graph
The basic 2 components making a graph are: \
  - **Nodes** \
  - **Edges** \
  
### What is a Node?
A Node, also known as a Vertex in graph theory literature can be thought of as a block/briefcase containing information and having specific attributes. In a network setting, it can also be thought of as a connection point where multiple connections are formed. \
Below is an example 2 nodes `a` and `b`.\
```{r, echo=FALSE}
b_graph <-
  create_graph(directed = FALSE) %>%
  add_node(label = "a") %>%
  add_node(label = "b")
render_graph(b_graph)
```
### What is an Edge?
An Edge is the connection/link between nodes. The best way to think about edges is with an example of a map where each city represents a Node, where the Edge is the highway connecting those 2 cities. \
Below is the continuation of the previous example, where now we have 2 **edges connecting**- one from `node a` to `node b` and the other from `node b` to `node b`. \
```{r, echo=FALSE}
b_graph <- b_graph %>% add_edge(from = "a",
                                to = "b") %>%
                         add_edge(from = "b",
                               to = "b") 
render_graph(b_graph)
```
**NOTE** For a valid graph, you cannot have an edge without a node BUT you can have a node or multiple nodes without any edges. To cement this concept, think about the map example again, for a road (EDGE) to exist you always need a start point and an end point. However, an isolated city (NODE) can exist without any connections with other cities. \

## Making Graphs
Now that we've covered the basic components of making a graph, let us look at some syntax, concepts and properties to make such graphs. \

To summarize what we have covered so far: \
  - Node: A component of a graph which can be visualized as a capsule containing information and often representing a connection point for edges. \
  - Edge: This is the connection running from one node to another. \
  - Graph is an object which shows and displays the relation between nodes and edges. \

### Syntax
#### Graph
The first step when making a graph is to actually declare the graph object. This is how you declare a graph. \
```{r, create_graph}
graph_a <- create_graph()
```
As the name suggests `create_graph()` function is used to create the graph object. Getting back to the map example think of this `create_graph()` function as laying down the blank sheet of paper(Graph) where you will be adding your cities(Nodes) and roads(edges).\

However there are more arguments which are passed when creating graphs, below is the basic syntax along with the breakdown of of the arguments.
```{r, eval=FALSE}
create_graph(nodes_df = NULL, edges_df = NULL, directed = TRUE,
  graph_name = NULL, attr_theme = "default", write_backups = FALSE)
```
```{r, echo=FALSE}
Arguments <- c("`nodes_df`", "`edges_df`", "`directed`",
  "`graph_name`", "`attr_theme`", "`write_backups`")

node <- "A VALID node data frame."
edge <- "A VALID edge data frame."
directed <- "A boolean to declare if the graph is **directed** or not. By default set to `TRUE`"
name <- "An optional string attribute to label the graph"
attr <- "A global theme which is set for the graph(both edges and nodes). If not selected then `default` attributes are applied globally and if declared as `NULL` then NO attributes are applied"
write <- "When set as `TRUE` each change in state is stored in a subdirectory in the current working directory, by default it is set to `FALSE`"

Description <- c(node, edge, directed, name, attr, write)

graph_list <- data.frame(Arguments, Description)
knitr::kable(graph_list)
```
Now is a good time to introduce the concept of **DIRECTED** graphs, which are obtained when we set the argument `directed = TRUE` in our graph. \
Well as the name suggests, directed graphs are graphs where the direction of the flow/movement between the nodes using the edge is specific to the direction in which we can travel on the edge. Below is an example of a directed graph-
```{r, echo=FALSE}
graph.dir <- create_graph()

graph.dir <- graph.dir %>% 
  add_n_nodes(n=3) %>%
  add_edge(from = 1, to = 2) %>%
  add_edge(from = 1, to = 3) %>%
  add_edge( from = 2, to = 3) %>%
  add_edge(from = 3, to = 1)

render_graph(graph.dir)
```
If we think about these integers `label` as sectors from Hunger Games, then what these edges show is the possible movement from one sector to another. With this given example we can denote that we can move between sector 1 and sector 3 BUT you can only enter sector 2 from sector 1 and you can only exit to sector 3 once you're in sector 2. \
Another way is to think about the road system, some roads allow you to travel in only 1 direction while others allow you to travel in both the directions. \
The discussion about node data frames and edge data frames will be covered in the coming sections. \


#### Node
Now that we are familiar with how graphs work, let us look at nodes and some properties related to nodes.
```{r, add_node}
graph_a <- graph_a %>% 
  add_node()
```
Here we first refer to the variable storing our graph as `graph_a`, then we use the PIPE `%>%` operator which tells R to perform the operation on our specified variable. As the name suggests, the `add_node()` function adds a default node to our specified graph. \
Let us now populate our graph with `c` more nodes using `add_n_nodes(n=c)` and **DISPLAY** our graph. To display the graph we use the `render_graph()` function. \
```{r, node_and_render}
# Adding 3 new nodes to the graph
graph_a <- graph_a %>%
  add_n_nodes(n = 3)

# Display our graph
render_graph(graph_a)
```
How about we delete a node now? The `delete_node(node=ID)` command is used to delete a node from a graph. Here `ID` is the **unique identity** which identifies the node in a graph. \
To get a list of all the identities in a graph, we use the `get_node_ids()` command. Here is an example of using both of these commands. \
```{r, node_ID}
graph_a %>% get_node_ids()
```
Deleting `node 4` in our graph. \
```{r, delete_node}
graph_a <- graph_a %>%
  delete_node(node = 4)
```
Let us check if the node was deleted in both the ways by checking the `ID` and also visually. \
```{r}
get_node_ids(graph_a)
```
Here, take note of a new way we used to call the function. So now you have 2 ways of calling the function however the method we learnt earlier is preferred as it is easier to read. \
Just to confirm, let us print out the graph and see if the node is actually removed. \
```{r}
render_graph(graph_a)
```
Let us now look at some more arguments we can pass when declaring a node. We will first look at of the general declaration syntax, followed by it's description of the arguments. \


```{r,add_node_all, eval=FALSE}
add_node(type = NULL, label = NULL, from = NULL, to = NULL,
  node_aes = NULL, edge_aes = NULL, node_data = NULL,
  edge_data = NULL)
```
**`type`** \ 
This is character type holder, which is used to group nodes together. This can be thought of as a parameter to pass into `group_by()` for further analysis. Think of the map example again with all the cities. Here you might choose to group the cities based on the province they belong to by declaring the type. \
**`label`** \
This can be thought of as the wrapper which is displayed on top of the node when the graph is displayed. So in our map example the city names will be used as the `label`. \
**`node_aes`** \
In addition to grouping similar nodes together, we can also change node attributes such as `shape`, `color`, `size`, depending on the need. It is recommended to use the helper function of `node_aes()` when assigning the aesthetics. \
Below is a table which lists some of the mutable aesthetic options available to choose from. The complete list of options can be found [here](http://visualizers.co/diagrammer/reference/node_aes.html#examples).
```{r, eval=FALSE}
node_aes(shape = NULL, style = NULL, color = NULL,
  fillcolor = NULL, fontname = NULL, fontsize = NULL,
  fontcolor = NULL, height = NULL,
  width = NULL, x = NULL, y = NULL, group = NULL,
  xlabel = NULL, URL = NULL, sides = NULL, margin = NULL)
```

```{r, node_aes_table, echo=FALSE}
# Making a table detailing some aesthetic options
Arguments <- c("`shape`", "`style`", "`color`",
  "`fillcolor`", "`fontname`", "`fontsize`",
  "`fontcolor`", "`height`", "`width`", "`x`", "`y`", "`group`", "`xlabel`",
  "`URL`", "`sides`", "`margin`")

shape <- "Shapes a node can take, eg: `circle`, `rectangle`, `polygon`, `plaintext`"
style <- "Possible style/pattern of the node, eg: `filled`, `invisible`, `diagonals`"
color <- "The color of the outline of the node. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
fillcolor <- "The color to fill the node with. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
fontname <- "The font system which will be used for the label"
fontsize <- "The size of the label"
fontcolor <- "The color of the label. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
height <- "The height of a node, the minimum possible is `0.02`. Note: if the label is unable to fit in the specified height, the height will be adjusted to fit the label"
width <- "The width of a node, the minimum possible is `0.02`. Note: if the label is unable to fit in the specified width, the width will be adjusted to fit the label"
x <- "Fixes the positioning of the node in the specified x-coordinate direction"
y <- "Fixes the positioning of the node in the specified y-coordinate direction"
group <- "This is the group to which the node belongs"
xlabel <- "A label that is placed outside but close to the node, PROVIDED the label doesn't overlap with other nodes"
URL <- "Assigns the URL associated with the node and upon clicking, the node will redirect to the specified URL"
sides <- "When the `shape` is `polygon`, this specifies the number of sides for the polygon"
margin <- "The amount of space between the label and the node"

Description <- c(shape, style, color, fillcolor, fontname, fontsize,
  fontcolor, height, width, x, y, group, xlabel,
  URL, sides, margin  )

aes <- data.frame(Arguments, Description)
  
knitr::kable(aes)
```
**`node_data`** \
This is a list of named vectors you can initialize to add some data into your node. In the map example, you can add data about the population density, area and other attributes about a node using this. Similar to aesthetics, the recommended helper function to add data is `node_data()`. \
**`from`** \
This is vector or single `ID` value which can be used to form an **incoming** edge with nodes that are already present in the graph.\
**`to`** \
This is vector or single `ID` value which can be used to form an **outgoing** edge with nodes that are already present in the graph.\
**`edge_aes`** \
Similar to `node_aes`, this field deals with aesthetic attributes of the edges connecting this note. We will cover this in the section dealing with Edges, the syntax along with the declaration will remain the same. \
**`edge_data`** \
Similar to `node_data`, this field deals with the data that can be stored in an edge. This will be covered in the section dealing with Edges, the syntax along with the declaration will remain the same. \
```{r, echo=FALSE}
graph <- create_graph()
```
Now let's connect these new things to our original example of the map. Here, we will be first declaring the `type` as "city", along with the name of city which will be stored as a `label`. We will be adding some aesthetics to our node along with some `node_data` and the link to the Wikipedia page for [Toronto](https://en.wikipedia.org/wiki/Toronto). \
```{r}
graph <- graph %>% add_node(type = "city", label = "Toronto",
                node_aes = node_aes(shape = "rectangle", style = "filled",
                                    color = "Red", fillcolor = "Black",
                                    fontcolor = "White", 
                                    URL = "https://en.wikipedia.org/wiki/Toronto"),                      node_data = node_data(area = 630.2, population = 2.7,
                                       GDP = 385.1, provience = "Ontario"))
render_graph(graph)
```
Now note in the render of our graph we can see the `label` and aesthetic features of our node **BUT** we have no idea about what data is stored in the node. \
To get the information stored in our node we use the `get_node_df()` function. 
```{r, node_df}
graph %>% get_node_df()
```
What is being displayed above is a data frame, this is formally known as **Node Data Frame(NDF)**. \

##### Node Data Frame(NDF)
The main concept and reasoning behind having an NDF is firstly, as previously discussed one cannot get an idea about the data stored in a node with the visual representation. Secondly, it is not efficient (in terms of computation) to always re-run the code and reconstruct your graph if you choose to pause your work and resume it at a later date.
Here, it would to be much more easy to reconstruct and store these nodes instead, and this is where NDF comes into play. \
Previously we looked at how to extract the NDF using `get_node_df()` command. Now to create an NDF, we use the function `create_node_df()`. Here is the basic syntax for it along with the breakdown of the arguments it takes.
```{r, eval=FALSE}
create_node_df(n, type = NULL, label = NULL, ...)
```
```{r, echo=FALSE}
Arguments <- c("`n`", "`type`", "`label`", "`...`")
n <- "The total number of nodes in the dataframe"
type <- "The optional `type` for EACH node"
label <- "Optional `label` for EACH node. `label = TRUE` assigns the `ID` as `label`"
data <- "Aesthetic attributes and Node data can be declared here"

Description <- c(n, type, label, data)
node_data <- data.frame(Arguments, Description)
knitr::kable(node_data)
```
Here is an example of creating an NDF similar to the theme of previous examples. For the purpose of simplicity, we will not be adding a lot of data variables in our nodes.
```{r}
node_df <- create_node_df(n = 3, type = "city", 
                          label = c("Toronto", "Ottawa", "Montreal"),
                          shape = "rectangle", style = "filled",
                          color = "Red", fillcolor = "Black",
                          fontcolor = "White",
                          provience = c("Ontario", "Ontario", "Quebec"))
```
```{r, echo=FALSE}
# displaying the results
node_df
```
Looking at the results of the previous command, we can see that we have a data frame with 3 nodes along with their attributes. Note this is similar to the regular data frames in R and can be created using `data.frame()`. However, `create_node_df()` is recommended as it allows for further validation (eg: checks `id` for the nodes).  [2](https://rich-iannone.github.io/DiagrammeR/ndfs_edfs.html) \


Let us conclude this section with looking at how to merge two or more NDFs into one. To do this, we use the `combine_ndfs()` function call. Here is an example- \
```{r}
# making 2 NDFs
node_df1 <- create_node_df(n = 2, 
                           type = c("a", "b"),
                           shape = "rectangle",
                           data = c(1,2)
                           )
node_df2 <- create_node_df(n = 2, 
                           type = c("c", "d"),
                           label = c("C", "D"),
                           data = c(3,4)
                           )
# merging the 2 NDF into 1
main_NDF <- combine_ndfs(node_df1, node_df2)
```
```{r, echo=FALSE}
main_NDF
```
Note that from the results we can notice that attributes which are not common among the data frames are not excluded in the merged data frame, but are assigned `NA` and new `ID` values are assigned to the nodes to prevent any overlap of `ID`. \

This concludes our discussion about the Nodes, the last thing about constructing graphs from an NDF will be covered in a later section. \


#### Edge
Recall that an edge is defined as a connection/link between nodes. Depending on the graph being directed or not, the direction of travel on an edge between nodes can be specific. Furthermore, **NOTE** that for an edge to exist we need a minimum of 1 node. For the purpose of simplicity, we will be working with directed graphs for most of this section.\

Let us look at the basic syntax used for creating an edge and, the required and possible arguments along with their description.
```{r, eval=FALSE}
add_edge(graph, from, to, rel = NULL, edge_aes = NULL,
  edge_data = NULL)
```
**`graph`** \
This is the  `dgr_graph` object to which the edge will be added. Can also use `%>%` declaration to avoid this eg: \
```{r, eval=FALSE}
#Can use this declaration
my_graph %>% add_edge()

# Or this
add_edge(my_graph)
```
**`from`**\
The starting-node/outgoing-node/exiting-node, from which the edge is connected. Here we can use the `label` of the node IF all the labels are non-empty and unique strings. By default `id` should be used as they are unique and hence less prone to errors. THIS IS NOT an optional argument. \
**`to`** \
The ending-node/incoming-node/entering-node, from which the edge is connected. Here we can use the `label` of the node IF all the labels are non-empty and unique strings. As is the case of `from`, by default `id` should be used and likewise THIS IS NOT an optional argument. \
**`rel`** \
Can use this `string` type attribute to declare a relation between the 2 nodes being connected with the particular edge. \ 
**`edge_aes`** \
Similar to `node_aes` from the previous section, we use this optional attribute to add and declare a list of aesthetic attributes to our edge. It is recommended to use the `edge_aes()` helper function to declare aesthetics. \
Below is the basic syntax to declare some of the common aesthetics along with their description followed by a simple example. The complete list of attributes can be found [here](http://visualizers.co/diagrammer/reference/edge_aes.html).
```{r, eval=FALSE}
edge_aes(style = NULL, penwidth = NULL, color = NULL,
  arrowsize = NULL, arrowhead = NULL, fontname = NULL, 
  fontsize = NULL, fontcolor = NULL, len = NULL,
  tooltip = NULL, URL = NULL, label = NULL, labelURL = NULL, 
  dir = NULL, headURL = NULL, headlabel = NULL, tailURL = NULL, 
  taillabel = NULL)
```

```{r, echo=FALSE}
Arguments <- c("style", "penwidth", "color",
  "arrowsize", "arrowhead",
  "fontname", "fontsize", "fontcolor", "len",
  "tooltip", "URL", "label", "labelURL", 
  "dir", "headURL", 
  "headlabel", "tailURL", "taillabel")

style <- "The style, visual render of the edge, eg: `solid`, `bold`, `dotted`"
penwidth <- "The thickness of the arrow"
color <- "The color of the outline of the edge. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
arrowsize <- "The scaling factor associated with the arrow, the minimum is `0.0` and the default value is `1.0`."
arrowhead <- " The style associated with the arrow head, can choose any from: `normal`, `vee`, `tee`, `dot`, `diamond`, `box`, `curve`, `icurve`, `inv`, `crow`, or `none`."
fontname <- "System of font to be used for ANY edge text"
fontsize <- "The font size to be used for ANY edge text"
fontcolor <- "The color of ANY edge text. Can choose from hexadecimal color code or using the default colors available in R, eg: `Red`, `Blue`, `Green`."
len <- "The length for the edge, the default is set to `1.0`"
tooltip <- "The text to display when hovering over an edge. If no argument is provided, then the edge defination is displayed (ie: [id_i] -> [id_j])."
URL <- "When a URL is provided, clicking on the edge will redirect to the provided URL."
label <- "The text displayed on the edge, it is positioned at the center of the edge"
labelURL <- "When a URL is provided, clicking on the 'label' will redirect to the provided URL."
dir <- "An optional direction type. This will be set to 'none' by default for undirected graphs and to 'forward' for directed graphs. One can declare and assign `both` or `back` to overwrite the default value and have the direction reversed OR make a multidirectional edge"
headURL <- "When a URL is provided, clicking on the 'label' of the head will redirect to the provided URL."
headlabel <- "The text displayed close to the incoming node"
tailURL <- "When a URL is provided, clicking on the 'label' of the tail will redirect to the provided URL."
taillabel <- "The text displayed close to the outgoing node"

Description <- c(style, penwidth, color,
  arrowsize, arrowhead,
  fontname, fontsize, fontcolor, len,
  tooltip, URL, label, labelURL, 
  dir, headURL, 
  headlabel, tailURL, taillabel)

edge_aes_data <- data.frame(Arguments, Description)
knitr::kable(edge_aes_data)
```
**`edge_data`**\
This is used to store data associated with an edge. Think about the previous map example- we can associate the average gas cost for taking a particular route by assigning gas prices along the edge or the time it will take to travel between the areas (nodes) using that edge. The helper function `edge_data()` is recommended to use when declaring edge data. Following is the syntax to use the function. \
```{r, eval=FALSE}
edge_data(...)
```
Here `...` is for the variable to be declared against the value associated with the variable for our edge. \

Let us cement these concepts about edges with an example. The graph we will be working with is shown below and we will be building upon this example.
```{r, echo=FALSE}
graph <- create_graph()
graph <- graph %>% add_n_nodes( n = 2,
                      label = c("Toronto", "London"))
render_graph(graph)
```
As we can see currently, this graph has 2 labeled nodes. Let us add some edges between these nodes to show the possible flights between the 2 locations along with the associated fares and other details.   \

```{r}
graph <- graph %>% add_edge(from = "Toronto", to = "London",
                   edge_aes = edge_aes(style = "solid",
                                       color = "Red",
                                       label = "Air Canada",
                                       labelfontsize = 3,
                      URL = "https://www.aircanada.com/us/en/aco/home.html"),
                   edge_data = edge_data(cost = 1000, 
                                         layover = "Yes", time = 17)) %>%
            add_edge(from = "Toronto", to = "London",
                             edge_aes = edge_aes(style = "solid",
                                                 color = "Blue",
                                                 label = "British Airways",
                                                 labelfontsize = 3,
                      URL = "https://www.britishairways.com/travel/home/public/en_ca/"),
                             edge_data = edge_data(cost = 2000, layover = "No",
                                                   time = 13)) %>%
    add_edge(from = 2, to = 1,
                   edge_aes = edge_aes(style = "solid",
                                       color = "Blue",
                                       labelfontsize = 3,
                      URL = "https://www.britishairways.com/travel/home/public/en_ca/"),
                   edge_data = edge_data(cost = 1300, layover = "Yes", time = 19)) %>%
  add_edge(from = 2, to = 1,
                   edge_aes = edge_aes(style = "solid",
                                       color = "Red",
                                       labelfontsize = 3,
                      URL = "https://www.aircanada.com/us/en/aco/home.html"),
                   edge_data = edge_data(cost = 1000, 
                                         layover = "Yes", time = 17))
render_graph(graph)
```
In the above example we added 4 edges along with some aesthetics to these edges depending on the condition we also added `URL` directing to the airlines websites and lastly we added some data to the edges. Here as we can see the data is not visible from the visual render of the graph. \
To get this data we use the function `get_edge_df()`, here is the use case for our example. \
```{r}
graph %>% get_edge_df()
```
So what is being displayed here is a data frame known as **Edge Data Frame(EDF)**. \
Think that now all the flights from Toronto to London are not operational for the time being. To account for this change we use `delete_edge()` function.
```{r}
graph.update <- graph %>% delete_edge(from = 2, to = 1)
```
```{r, echo=FALSE}
render_graph(graph.update)
```
#### Edge Data Frame(EDF) 
The main concept and reasoning for having EDF is firstly as previously discussed one cannot get an idea about the data stored in an edge with the visual representation and because of the associated complexity involved re-running the code. \
Now to reconstruct and store these edges NDF we use the help of the following functions.\

We have looked at how to extract the EDF using `get_edge_df()` command. Now to create an EDF we use function `create_edge_df()`. Here is the basic syntax for it along with the breakdown of the arguments it takes. \
```{r, eval=FALSE}
create_edge_df(from, to, rel = NULL, ...)
```
```{r, echo=FALSE}
Arguments <- c("`from`", "`to`", "`rel`", "`...`")
from <- "A vector of `integer` containing node `id` from which the edges are leaving. This vector length must match the `to` vector's length"
to <- "A vector of `integer` containing node `id` where the edges are entering. This vector length must match the `from` vector's length"
rel <- "An optional `chracter` argument that can be passed to show the relation between the nodes "
dat <- "This is where all the attributes related to the aesthetics and data can be declared and stored."
Description <- c(from, to, rel, dat)

edf_data <- data.frame(Arguments, Description)
knitr::kable(edf_data)
```
Now often times we will be required to combine EDFs in one main EDF. We do this using the `combine_edfs(...)` function where `...` are valid EDFs. \
Below in an example which covers both creating and merging of 2 simple EDFs.
```{r}
# Creating the EDF
edf.a <-
  create_edge_df(
    from = c(1, 2, 3),
    to = c(2, 3, 1),
    value = c(10, 20, 50),
    color = "Blue")
edf.b <- create_edge_df(
    from = c(4, 4, 5),
    to = c(6, 5, 6),
    data = c(11, 20, 50),
    color = "Red")

# Merging the EDF
main_edf <- combine_edfs(edf.a, edf.b)
```
```{r, echo=FALSE}
main_edf
```
Note from the results we can notice the attributes which are not common among the data frames are not excluded in the merged data frame but are assigned `NA` and new `id` values are assigned to the edges preventing any overlap of `id`. \

This concludes our discussion about the Edges and now we have all the necessary tools to construct graphs directly given a valid NDF and EDF. \

#### Constructing graphs from EDF and NDF
Now that we have an idea about how EDF and NDF work let us now look at how we can link these two to construct a graph. \
Recall from the section where we discussed `create_graph()` the two arguments `node_df` and `edge_df` will now be declared to make a graph. Lets go over a quick example where we declare the NDF and EDF and then combine the two into a graph object. \
```{r}
# Create a node data frame
ndf <-
  create_node_df(
    n = 3,
    label = c("1", "2", "3"),
    type = "lower",
    style = "filled",
    color = "Pink",
    shape = "diamond")

# Create an EDF
edf <-
  create_edge_df(
    from = c(1, 2, 3, 2, 4),
    to = c(3, 3, 1, 1, 5))

# Create the graph from NDF and EDF
graph <-
  create_graph(
    nodes_df = ndf,
    edges_df = edf)

render_graph(graph)
```
Voila! We finally have constructed a graph object from NDF and EDF. Here one thing to note is that for the `id` which don't match, in our case {4,5} coming from EDF our new graph object has created 2 more nodes to adjust for this. \
This shows that when combing EDF and NDF the number of nodes in the final graph is not limited to the dimension of the NDF BUT also includes the length of the Union of the unique `from` and `to` vector. \


## Refrences
`DiagrammeR` \
[Introduction](http://visualizers.co/diagrammer/) \
[Applications](https://www.javatpoint.com/graph-theory-applications#:~:text=Graphs%20are%20used%20to%20represent%20networks%20of%20communication.&text=Graph%20theory%20is%20used%20to,shortest%20path%20between%20two%20nodes.) \

`Node` \
[Adding node](http://visualizers.co/diagrammer/reference/add_node.html) \
[Node Aesthetic](http://visualizers.co/diagrammer/reference/node_aes.html) \
[Node Data](http://visualizers.co/diagrammer/reference/node_data.html) \
[NDF](http://visualizers.co/diagrammer/reference/add_node_df.html)\

`Edge` \
[Adding Edge](http://visualizers.co/diagrammer/reference/add_edge.html)
[Edge aesthetics](http://visualizers.co/diagrammer/reference/edge_aes.html) \
[Edge Data](http://visualizers.co/diagrammer/reference/edge_data.html) \
[EDF](http://visualizers.co/diagrammer/reference/add_edge_df.html) \

`EXTRA` \
[Function List](http://visualizers.co/diagrammer/reference/index.html) \


## Exercises

### Question 1
 You can have a(n) ___ without a(n) ____ ?    \
a. Edge, Node \
b.  Node, Edge \

### Question 2
You can have a valid graph without ___ ?
(hint: what happens when you pass `create_graph()` without any arguments) \
a. an edge but not without a node \
b. a node but not an edge \
c.  an edge or a node  \

### Question 3
A loop in a graph is when we have an edge starting and ending on the same node? \
a.  True \
b. False \

### Question 4
`get_node_info()` is used to view the data in a node? \
a.  False \
b. True \

### Question 5
NDFs with common `id` and `label` can merge into 1 NDF? \
a.  True \
b. False \

### Question 6
When NDF and EDF are combined into a graph object, the number of nodes depends on NDF only? \
a. True \
b.  False \

### Question 7
NDF and EDF can be created using `data.frame()` command instead of their specific commands? \
a.  True \
b. False \

### Question 8
`add_node(n=3)` will add 3 nodes to the graph? \
a. True \
b.  False \

### Question 9
`add_n_edges(n=2)` with valid `to` and `from` arguments will add 2 edges to the graph? \
a. True \
b.  False \
 
### Question 10
When making a graph from NDF and EDF the number is edges is determined by the length of `to` or `from` vector? \
a.  True \
b. False \